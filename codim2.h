#ifndef CODIM2H
#define CODIM2H
#include <unordered_set>
using namespace std;

// forward declarations ...
struct CoDim2;
struct Simplex;

/*
Vertices are points on an integer grid which are mapped
into physical coordinates depending on  grain  and  offset .
Physical coordinates are generated as-needed when, for example,
doing a boundary check or calling the residual function.
A very small subset of all such vertices (i.e.,
those in the vicinity of the manifold) can be "labeled".
A point of the integer grid that is a vertex of one of the
enumerated simplices is labeled with residual values
and (optionally) values for the user-defined functions of dimensions
[nr] and [nu] respectively. These data are captured in the following
structure. Instances of this structure are kept in a hash
tabled indexed by said integer coordinates
E.g., for nd == 3

(1,-6,17) -> (rsd[nr],usf[nu]); label values of vertex of integer grid

These values are recovered when needed for an intersection check.
Once a vertex has been labeled, the residual (and user) functions
should _not_ be evaluated again, both for efficiency
and consistency.
*/

struct VertLab
{
  CoDim2* root_p;
  int const nd; // dimension of domain
  int const nr; // dimension of range nr=nd-2
  int const nu; // >=0; number of user-defined functions
  int* vc;     // [nd]; integer coords; point on said integer grid
  double* rsd; // [nr] provided by user's residual function
  double* usf; // [nu] ditto (but optional,nu >= 0)
  VertLab(CoDim2*);
 ~VertLab();
};

/*
The routine  intersection_check  (to be described) computes
the (possibly empty) intersection of the manifold with a _facet_ of a simplex,
where a facet is, itself, a simplex in the range space
(i.e, R^{nr}) so has  nr+1  vertices (each of dimension  nd ).
As described in the theory,
a facet is identified uniquely be specifying a simplex \sigma in R^{nd} 
and two indices 0 <= index0,index1 <= nd  to select
two different vertices of \sigma . The vertices
of \sigma (nd+1 of them) which are different
from both  index0  and  index1  (hence nd+1-2 = nd-1 = nr+1)
are then the (nr+1) vertices of the selected facet.
Those facets which do intersect the manifold are recorded
in a hash table which is keyed by \sigma and the two indices.
The intersection between a facet and the manifold is represented
by giving the bary-centric coordinates of the intersection w.r.t.
the vertices of the facet.
*/

struct Facet
{
  CoDim2* root_p;
  int const nd;
  int const nr;
  int const nu;
  int* tau; // [nd x (nr+1)]; int coords of vertices
  double* coord; // [nd]; b.c. of vertex coords
  double* rsd;   // [nr]
  double* usf;   // obtained by interpolation; possibly over-written
  Facet(CoDim2*,int*);
 ~Facet();
};

/*
Convex polygon of points in R^{nd}
must be at least 3 ...
Because this polygon is constructed by the
intersection of a hyperplane and a simplex,
there can be at most  nd+1  vertices.
*/
struct ConvexPoly
{
  CoDim2* root_p;

  int n_verts; // [0,...,(nd+1)]
  Facet* *fp_list; // [nd+1]
  int* id_list;    //[2*(nd+1)]; // record indices ...

  ConvexPoly(CoDim2* root_p);
 ~ConvexPoly();
  void _sequence(); //establish circular order for vertices 
  void output_stl(int const,int const,int const,FILE*);
  void response_stl(int const,FILE*);  
};

// declarations for unordered_set type used later ...
struct SimplexHash
{
  size_t operator()(Simplex* const& x_p) const;
};

struct SimplexEqual
{
  bool operator()(Simplex*const &x, Simplex*const &y) const;
};

struct VertLabHash
{
  size_t operator()(VertLab* const& x_p) const;
};

struct VertLabEqual
{
  bool operator()(VertLab*const &x, VertLab*const &y) const;
};

struct FacetHash
{
  size_t operator()(Facet* const& x_p) const;
};

struct FacetEqual
{
  bool operator()(Facet*const &x, Facet*const &y) const;
};

/*
On discrete rectlinear grid with step size  grain  ;
Each simplex is generated by a "pivoting" operation
from a neighbor, all starting from an initial simplex
(sigma0) centered on the user-supplied starting point.
Vertices always have integer coords and can have
physical (measurement) coords (e.g., 3.27 Volts).
The residual function  f()  above is called for each
vertex (using its physical coords) to provide 
a so-called "residual label" of dimension  nr  as well as optional
user-defined functions on the vertex. Residuals should all
be near zero.

The key to the whole algorithm is the  get_cross_section  operation
on a simplex. This routine enumerates all facets of the simplex (objects
of dimension 2 less than the simplex) and determines which
of these actually intersect the manifold (more specifically,
a local linear approximation to the manifold). Points of
intersection are recorded and the convex hull of these
points forms a cross-section between the simplex and the
manifold which is reported to the user (e.g., for
graphical rendering of the manifold). Then, for those
facets which _do_ intersect the manifold, the code looks
for neighboring simplices containing these facets
and which have NOT been previously enumerated.

Simplices are assigned a  serial  number in the order
in which they are generated. This number is used then
to implement a priority score when selecting a new
simplex to grow the boundary.
*/
struct Simplex
{
  CoDim2* root_p; // point to single driver structure
  int const nd; // echos for convenience
  int const nr;
  int const nu;

  // integer grid for origin, then
  // permutation to select simplex within
  // a hypercube with that origin;
  // these data uniquely specify a simplex;
  // see discussion in Henderson
  int* cnr;    // [nd]
  int* per;    // [nd]
  
  int* vcs;    // [nd x (nd+1)]
  int vcs_dirty;
  int serial;

  void update_vcs();
  void phys_v(double* vertices); // physical coords when needed
  void phys_v(const int* tau,double* vertices); // physical coords when needed

  Simplex(CoDim2* root_p);
 ~Simplex();

  // generate a neighboring simplex and identify unique new vertex
  void pivot(int const index, Simplex* *o_neigh_p,int *new_v);

  void show();

  // extract a  nr-dimensional simplex ("facet")
  // by specifying two vertex coords
  void get_facet(int const i0,int const i1,int* tau);

  // test if a facet crosses the manifold
  // if so allocate new  Facet  and return pointer
  // otherwise null
  Facet* intersection_check(int const i0,int const i1,int* tau);

  // find all facets of this simplex that intersect the manifold
  // and collect as a convex polygon
  // expand with their neighbors ...
  void get_cross_sect(ConvexPoly& cvx
                     ,unordered_set<Simplex*,SimplexHash,SimplexEqual>& neighbors);
};

// top-level data structure ...
struct CoDim2
{
  int const nd;   // >= 3; dimension of domain space
  int const nr;   // >= 1; dimension of range space; nd-2
  int const nu;   // >= 0; number of user-defined function values

  double* y0;     // [nd] starting point; remember for raster ops ...
  double const grain; // granularity
  double* offset; // [nd]
  int tot_comb; // (nd+1)*nd/2
  int* fv_tab;  // [tot_comb x (nd+1)]

  int usf_eval_switch;
  void(*ResidualFunction)(int const nd,int const ufe,const double* y,double* rsd,double* usf,const void* param);
  void(*BoundaryFunction)(int const nd,const double* y,double *score,const void* param);
  FILE* fp_inform;
  FILE* fp_output;
  void* param;
  int max_front_size;
  bool interpolate_user_functions;
  int serial; // counter for simplices ...

  // candidate simplices
  unordered_set<Simplex*,SimplexHash,SimplexEqual> frontier;

  // finished simplices
  unordered_set<Simplex*,SimplexHash,SimplexEqual> prev_enum;

  // residuals and user-functions
  unordered_set<VertLab*,VertLabHash,VertLabEqual> vert_lab_tab;

  // intersections between manifold and facets
  unordered_set<Facet*,FacetHash,FacetEqual> fac_tab;

  double const boundary_epsilon; // a small number ...
  // accum boundary function over all vertices
  double boundary_score(double* vertices) const;
 
  // stuff for hash functions ...
  // possibly extended if  nd > 7 ...
  long const _prime_tab[7]={3,5,7,11,13,17,19};
  long* prime_tab;

  CoDim2(int const nd, int const nu, double const grain);
 ~CoDim2();

  // create initial simplex
  void start(const double* y0);

  // call repeatedly until frontier is empty ...
  void enumerate(ConvexPoly& cvx);

  // running progress indicator
  void progress();

  // typically call at end of enumeration ...
  void statistics();
};

#define SOME_UTILS // avoid collision with local definitions
static inline int iabs
(
int const a
)
{
  return (a < 0 ? -a : a);
}

static inline int between
(
double const x,
double const lo,
double const hi
)
{
  assert( lo < hi );
  if( x < lo )
    return 0;
  if( x > hi )
    return 0;
  return 1;
}

static inline double min(double const a,double const b)
{
  return (a<b? a : b);
}

static inline double max(double const a,double const b)
{
  return (a>b? a : b);
}
#endif
